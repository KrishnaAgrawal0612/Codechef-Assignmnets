Brothers from different node:
class Solution {
    public static int countPairs(Node root1, Node root2, int x) {
        // Code here
        ArrayList<Integer> first=new ArrayList<>();
        HashSet<Integer> second=new HashSet<>();
        int count=0;
        inline(root1,first);
        inlineset(root2,second);
        for(int i=0;i<first.size();i++){
            if(second.contains(x-first.get(i))){
                count++;
                
            }
            
        }
        return count;
        
        
        
    }
    public static void  inline(Node root,ArrayList<Integer> ans){
        if(root==null) return ;
        inline(root.left,ans);
        ans.add(root.data);
        inline(root.right,ans);
        return ;
    }
     public static void inlineset(Node root,HashSet<Integer> ans){
        if(root==null) return ;
        inlineset(root.left,ans);
        ans.add(root.data);
        inlineset(root.right,ans);
        return ;
    }
}
.........................................................................................................................................................................

Find Common nodes in two bsts:

class Solution {
    // Function to find the nodes that are common in both BST.
    public static ArrayList<Integer> findCommon(Node r1, Node r2) {
        // code here
        ArrayList<Integer> finalans=new ArrayList<>();
        ArrayList<Integer> first=new ArrayList<>();
        HashSet<Integer> second=new HashSet<>();
        inline(r1,first);
        inlineset(r2,second);
        Collections.sort(first);
        for(int i=0;i<first.size();i++){
           if(second.contains(first.get(i))){
               finalans.add(first.get(i));
           }
        }
        return finalans;
        
        
        
    }
    public static void  inline(Node root,ArrayList<Integer> ans){
        if(root==null) return ;
        inline(root.left,ans);
        ans.add(root.data);
        inline(root.right,ans);
        return ;
    }
     public static void inlineset(Node root,HashSet<Integer> ans){
        if(root==null) return ;
        inlineset(root.left,ans);
        ans.add(root.data);
        inlineset(root.right,ans);
        return ;
    }

    
}

...........................................................................................................................................................................

BST with dead end:


class Solution {
    public boolean isDeadEnd(Node root) {
        // Code here
        return helper(root,1,Integer.MAX_VALUE);
        
    }
    public boolean helper(Node root,int min,int max){
        if(root==null) return false;
        if(min==max) return true;
        return (helper(root.left,min,root.data-1)|| helper(root.right,root.data+1,max));
    }
}

..................................................................................................................................
